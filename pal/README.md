# Porting guide

## Port Platfrom Abstraction Layer

To port the Software Framework on you Host platfrom please follow this [guidance](NEW_PAL_TEMPLATE)

## Port Crypto module for Platfrom Abstraction Layer

The Crypto PAL helps a Host MCU to perfrom shielded communication (protected Infineon I2C protocol) between the Host and the Trust M
If you don't use shielded connection you can skip this module

Currently three Crypto PALs are supported via third-party libraries (should be provided at compilation/linking time)
1. mbed TLS Crypto Library
1. OpenSSL Crypto Library
1. WolfSSL Crypto Library

There are three functions required to be implemented by the Crypto PAL, these are:
1. `pal_crypt_tls_prf_sha256`    
    <details> <summary> Test Vectors </summary> 

    ```c
    **********************************************************************************************

    static const uint8_t example_secret[] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };

    static const uint8_t example_label[] = {
        0x42, 0x61, 0x62, 0x79, 0x6c, 0x6f, 0x6e, 0x20,
        0x50, 0x52, 0x46, 0x20, 0x41, 0x70, 0x70, 0x4e,
        0x6f, 0x74, 0x65
    };

    static const uint8_t example_seed[] = {
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f
    };

    static const uint8_t example_result[] = {
        0xbf, 0x88, 0xeb, 0xde, 0xfa, 0x78, 0x46, 0xa1,
        0x10, 0x55, 0x91, 0x88, 0xd4, 0x22, 0xf3, 0xf7,
        0xfa, 0xfe, 0xf4, 0xa5, 0x49, 0xbd, 0xaa, 0xce,
        0x37, 0x39, 0xc9, 0x44, 0x65, 0x7f, 0x2d, 0xd9,
        0xbc, 0x30, 0x83, 0x14, 0x47, 0xd0, 0xed, 0x1c,
        0x89, 0xf6, 0x58, 0x23, 0xb2, 0xec, 0xe0, 0x52,
        0xf3, 0xb7, 0x95, 0xed, 0xe8, 0x6c, 0xad, 0x59,
        0xca, 0x47, 0x3b, 0x3a, 0x78, 0x98, 0x63, 0x69,
        0x44, 0x65, 0x62, 0xc9, 0xa4, 0x0d, 0x6a, 0xac,
        0x59, 0xa2, 0x04, 0xfa, 0x0e, 0x44, 0xb7, 0xd7
    };

    **********************************************************************************************

    // Test Vector from website www.ietf.org/mail-archive/web/tls/current/msg03416.html
    // Secret
    static const uint8_t tls_at_ietf_secret[] = 
    {
        0x9b,0xbe,0x43,0x6b,0xa9,0x40,0xf0,0x17,    
        0xb1,0x76,0x52,0x84,0x9a,0x71,0xdb,0x35      
    };

    // Seed
    static const uint8_t tls_at_ietf_seed[] = 
    {
        0xa0,0xba,0x9f,0x93,0x6c,0xda,0x31,0x18,    
        0x27,0xa6,0xf7,0x96,0xff,0xd5,0x19,0x8c       
    };

    // Label test label (0x74,0x65,0x73,0x74,0x20,0x6c,0x61,0x62,0x65,0x6c)
    static const uint8_t tls_at_ietf_label[] = 
    {
        0x74,0x65,0x73,0x74,0x20,0x6c,0x61,0x62,
        0x65,0x6c
    };

    // Output
    static const uint8_t tls_at_ietf_output[] = 
    {
        0xe3,0xf2,0x29,0xba,0x72,0x7b,0xe1,0x7b,    
        0x8d,0x12,0x26,0x20,0x55,0x7c,0xd4,0x53,    
        0xc2,0xaa,0xb2,0x1d,0x07,0xc3,0xd4,0x95,    
        0x32,0x9b,0x52,0xd4,0xe6,0x1e,0xdb,0x5a,    
        0x6b,0x30,0x17,0x91,0xe9,0x0d,0x35,0xc9,    
        0xc9,0xa4,0x6b,0x4e,0x14,0xba,0xf9,0xaf,    
        0x0f,0xa0,0x22,0xf7,0x07,0x7d,0xef,0x17,    
        0xab,0xfd,0x37,0x97,0xc0,0x56,0x4b,0xab,    
        0x4f,0xbc,0x91,0x66,0x6e,0x9d,0xef,0x9b,    
        0x97,0xfc,0xe3,0x4f,0x79,0x67,0x89,0xba,    
        0xa4,0x80,0x82,0xd1,0x22,0xee,0x42,0xc5,    
        0xa7,0x2e,0x5a,0x51,0x10,0xff,0xf7,0x01,    
        0x87,0x34,0x7b,0x66    
    };
    ```

    </details>

1. `pal_crypt_encrypt_aes128_ccm`
    <details> <summary> Test Vectors </summary> 

    ```c
    /* key */
    static const uint8_t key[] =
    {
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
    };

    /* nonce */
    static const uint8_t nonce[] =
    {
        0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa5
    };

    /* plaintext */
    static const uint8_t plainText[] =
    {
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e
    };

    //Associated Data
    static const uint8_t aData[] =
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
    };

    //Cipher text
    static const uint8_t cipherText[] =
    {
        0x58, 0x8c, 0x97, 0x9a, 0x61, 0xc6, 0x63, 0xd2,
        0xf0, 0x66, 0xd0, 0xc2, 0xc0, 0xf9, 0x89, 0x80,
        0x6d, 0x5f, 0x6b, 0x61, 0xda, 0xc3, 0x84
    };

    //MAC
    static const uint8_t mac[] =
    {
    0x17, 0xe8, 0xd1, 0x2c, 0xfd, 0xf9, 0x26, 0xe0
    };
    ```

    </details>
    
1. `pal_crypt_decrypt_aes128_ccm`
    <details> <summary> Test Vectors </summary> 

    ```c
    /* key */
    static const uint8_t key[] =
    {
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf
    };

    /* nonce */
    static const uint8_t nonce[] =
    {
        0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa5
    };

    /* plaintext */
    static const uint8_t plainText[] =
    {
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e
    };

    //Associated Data
    static const uint8_t aData[] =
    {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
    };

    //Cipher text
    static const uint8_t cipherText[] =
    {
        0x58, 0x8c, 0x97, 0x9a, 0x61, 0xc6, 0x63, 0xd2,
        0xf0, 0x66, 0xd0, 0xc2, 0xc0, 0xf9, 0x89, 0x80,
        0x6d, 0x5f, 0x6b, 0x61, 0xda, 0xc3, 0x84
    };

    //MAC
    static const uint8_t mac[] =
    {
    0x17, 0xe8, 0xd1, 0x2c, 0xfd, 0xf9, 0x26, 0xe0
    };
    ```

    </details>
    
